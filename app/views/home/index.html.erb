
<div id="main">
	

	<!-- Intro -->
	<section id="top" class="one dark cover">
		<div class="container">
			<header>
				<h2 class="alt">Erlang ODBC Tips</h2>
				<h3>A collection of helpful hints for developers using Erlang and ODBC.</h3>
				<p>Using Erlang's ODBC (Open Database Connectivity) support to access a SQL database can be an exercise in frustration, but this guide will get you started in no time.</p>
			</header>			
			<footer>
				<a href="#quickstart" class="button scrolly">Let's get started!</a>
			</footer>
		</div>
	</section>
		
	<!-- Quickstart -->
	<section id="quickstart" class="two">
		<div class="container">	
			<header>
				<h2>First Things First</h2>
			</header>
			<p class="alert alert-info">
				<span class="icon fa-graduation-cap"></span>
				While this guide <em>should</em> be accessible to everyone, we assume you have some practice building Erlang OTP applicaions. We won't spend time explaining syntax and basic concepts. If you come across something you don't recognize, checkout the excellect <a href="http://learnyousomeerlang.com/">Learn You Some Erlang</a> online book.
			</p>				
			<p>If you work with Erlang long enough, you'll find yourself needing to connect to a SQL database because you have to interact with a legacy system or have some data that demands strong consistency.					
			</p>
			<p>To achieve this, you'll need to use ODBC. Erlang ships with native ODBC support as part of the standard OTP libraries, so it's available in every installation without any extra effort.
			</p>
			<h3>Where  To Get Help</h3>
			<p>
				If you're using Erlang ODBC for the first time, you're <em>going</em> to need some extra help at some point (hopefully that's why you're here!). Here are some good resources to check out if you get into a pickle.
			</p>
			<ul>
				<li>
					The official Erlang ODBC <a href="http://www.erlang.org/doc/apps/odbc/getting_started.html">getting started guide</a>.
				</li>
				<li>
					Details of the ODBC <a href="http://www.erlang.org/doc/man/odbc.html">API</a>.
				</li>
				<li>
					The official Erlang ODBC <a href="http://www.erlang.org/doc/apps/odbc/odbc.pdf">reference manual</a> (as PDF).
				</li>
			</ul>
			<h3>Preparing To Connect</h3>
			<p>An ODBC connection requires a DSN (Data Source Name) to be configured on the system. Unfortunately, Erlang ODBC does not support file DSNs, so the DSN must be configured using the Windows ODBC configuration utilities.				
			</p>
			<p>Stata has published an excellent tutorial <a href="http://www.stata.com/support/faqs/data-management/configuring-odbc-win/"> explaining how to set up a Windows Data Source Name</a>. Be sure to follow the instructions for your version of Windows. Also, an ODBC DSN can be either a User DSN or a System DSN. A User DSN is only available to the user who created it, while a System DSN is available to all users of the local system.					
			</p>
			<p class="alert alert-danger">
				<span class="icon fa-warning"></span> 
				Don't forget to configure a DSN on each environment to which you plan to deploy your compiled Erlang release! The lack of support for file DSNs means you cannot distribute the DSN configuration as part of an Erlang release package. Sadly, you'll need to perform this step manually for each machine on which you wish to run your application.
			</p>
			<footer>
				<a href="#connecting" class="button scrolly">It's time to connect!</a>
			</footer>
		</div>
	</section>

	<!-- Connecting -->
	<section id="connecting" class="three">
		<div class="container">
			<header>
				<h2>Connecting</h2>
			</header>
			<p>
				The first steps to using ODBC in Erlang are to declare a dependency on the ODBC OTP application and make sure the application is started. If you use a build system like <a href="https://github.com/basho/rebar">Rebar</a> you'll need to declare a dependency on <code>odbc</code> in the applications list inside your <code>reltool.config</code> file:
			</p>
			<pre class="brush: erlang">
			...
			{rel, "MyApp", "1.0.0",
			    [kernel,
			     stdlib,
			     odbc]
			},
		    ...
		    </pre>
		    <p>If you're using a bootstrap script for development, or are manually starting the applications you need, simply add a line to start the <code>odbc</code> application to your initialization routine:
		    <pre class="brush: erlang">
		    -module(myapp_bootstrap).
			-export([start/0]).

			start() ->
				odbc:start(),	
			    application:load(myapp),
			    application:start(myapp).
		    </pre>
		    <p>A final alternative is to use a command line argument when starting the shell:</p>
		    <pre class="brush: erlang;">
		    erl -s odbc start
		    </pre> 

		    <p class="alert alert-info">
				<span class="icon fa-cogs"></span>
				You can ensure that the <code>odbc</code> OTP application is running by typing <code>application:which_applications().</code> into the Erlang shell and looking for a line like <code>{odbc,"Erlang ODBC application","2.10.18"}</code>.
			</p>

		    <p>At this point, you should have a working environment with all the dependencies that you need to connect to a SQL database using Erlang ODBC. The last step to get up and running is to gather your connection details into a connection string and attempt a simple SQL query.</p>
		    <p>The connection string requires three pieces of information: the name of the DSN that you configured earlier, the SQL login name, and the SQL password. Normally, we'd store this information in the application configuration file, but for this guide we'll declare it as a string variable for simplicity:
		    </p>
		    <pre class="brush: erlang">
		    	ConnectionString = "DSN=MyAppDSN;UID=me;PWD=secret"
		    </pre>
		    <p>The name of the DSN, in this case <code>MyAppDSN</code> must exactly match the name of the DSN that you created in the Windows ODBC tool. Of course the user name and password must be legitimate credentials for your SQL instance.
		    </p>
		    <p>With the connection string ready, let's write a function to test our database connection with the simple query <code>SELECT 1;</code>:
		    </p>
		    <pre class="brush: erlang">
		    -module(myapp_sql_repo).
		    -export([test_connection/0]).

		    %%%==========================================
			%%% Client API
			%%%==========================================
			test_connection() ->
				Sql = "SELECT 1;",
				Connection = connect(),
			    case odbc:sql_query(Connection, Sql) of
			        {selected, Columns, Results} ->
			          io:format("Success!~n Columns: ~p~n Results: ~p~n", 
			          	[Columns, Results]),
			          ok;
			        {error, Reason} ->
			            {error, Reason}                           
			    end. 

		    %%%==========================================
			%%% Internal functions
			%%%==========================================
			connect() ->
			    ConnectionString = "DSN=MyAppDSN;UID=me;PWD=secret",    
			    {ok, Conn} = odbc:connect(ConnectionString, []),
			    Conn.
		    </pre>
		    <p>We now have everything we need to test our ODBC connection on the SQL database. Let's give it a try:
		    </p>
		    <pre class="brush: bash">		    	
				$>erl -s odbc start
				Eshell V5.10  (abort with ^G)
				1> myapp_sql_repo:test_connection().
				Success!
				 Columns: [[]]
				 Results: [{1}]
				ok
		    </pre>
		    <p>If something has gone wrong with SQL itself, you should see an <code>{error, Reason}</code> tuple with a relevant error message. Another common problem may occur if something is wrong with your connection string, preventing your program from establishing an ODBC connection. In that case, you'll see a message similar to:		    	
		    </p>
		    <pre class="brush: bash">		    	
				$>erl -s odbc start
				Eshell V5.10  (abort with ^G)
				1> myapp_sql_repo:test_connection().				
				** exception error: no match of right hand side value {error,
				                                                       "[Microsoft][ODBC Driver
				Manager] Data source name not found and no default driver specified SQLSTATE IS:
				 IM002 Connection to database failed."}
				     in function  myapp_sql_repo:connect/0 (myapp_sql_repo.erl, line 33)
				     in call from myapp_sql_repo:test_connection/0 (myapp_sql_repo.erl, line 9)
				4>
		    </pre>
		    <p>The message clearly indicates that my DSN name (in the connection string) is incorrect.<p>
		</div>
	</section>

	<!--
	IDEAS FOR GOTCHAS:

	- The 64-bit/32-bit problem
	- NOCOUNT messing up pattern matching
	- Buffer overflow/string truncation
	- Unicode character encoding
	- Wonky support for NVARCHAR(MAX)
	- Sequentializing calls anti-pattern (floods mailbox due to IO time)


		TODO: put images in static folder, rather than S3!

	-->

	<section id="gotchas" class="four">
		<div class="container">	
			<header>
				<h2>Gotchas (These will bite you in the butt)</h2>
			</header>
			<p>There are plenty of wonky things in the Erlang ODBC library that can rear up and bite you without warning. Usually, they are poorly documented and hard to troubleshoot. This section contains a collection of errors that we've seen in the wild, along with some advice in case you experience them.				
			</p>

			<h3>64-Bit/32-Bit Architecture Mismatch</h3>
			<img src="images/32-bit.png" title="Setting up a 32-bit DSN" class="floatright w300" />
			<br />
			<img src="images/64-bit.png" title="Setting up a 64-bit DSN" class="floatright w300" />

			<p>On a 64-bit Windows machine, it's possible to setup both 32-bit and 64-bit ODBC DSNs in the data sources set up dialog. This can potentially create a problem if you've installed a 32-bit build of Erlang & OTP, but you are trying to connect to a 64-bit ODBC DSN.</p>
			<p>The first step to preventing or fixing this issue is to determine what type of Erlang build you're running, as this will determine which type of DSN you need. On Windows, running the <code>werl</code> program will open an Erlang shell including the details of the build:
			</p>
			<pre class="brush: bash">
				$>werl
				Erlang R16A (erts-5.10) [smp:8:8] [async-threads:10]

				Eshell V5.10  (abort with ^G)
				1> 
			</pre>
			<p>Note that the first line contains the Erlang version, <code>R16A</code>, and the ERTS version, <code>5.10</code>, but there is no indication of the architecture. That means this system is running a 32-bit build of Erlang and will need a 32-bit DSN. A 64-bit Erlang build will be clearly indicated with <code>[64-bit]</code> along with the other details:
			</p>
			<pre class="brush: bash">
				>werl
				Erlang R16A (erts-5.10) [64-bit] [smp:8:8] [async-threads:10]

				Eshell V5.10  (abort with ^G)
				1> 
			</pre>
			<img src="images/odbc_start_menu.png" title="Finding the correct DSN set up tool in the start menu" class="floatright w200" />
			<p>Knowing exactly what architecture you need, you can now setup the matching type of DSN. Note that Windows has separate set up utilities for each, so you need to launch the correct one.</p>
			<ul>
				<li>For a 64-bit DSN (on a 64-bit Windows installation) run <code>c:\windows\system32\odbcad32.exe</code></li>
				<li>For a 32-bit DSN (on a 64-bit Windows installation) run <code>c:\windows\sysWOW64\odbcad32.exe</code></li>
			</ul>
			<p>Looking at those paths, it seems counter-intuitive that the 32-bit config tool would be in a folder called <code>sysWOW64</code>, but there you have it.</p>
			<p>If you've already set up a DSN, but you've inadvertently used the wrong architecture, you'll see an <code>architecture mismatch</code> error when trying to connect:
			</p>
			<pre class="brush: bash">
				$>erl -s odbc start
				Eshell V5.10  (abort with ^G)
				1> c(myapp_sql_repo).
				{ok,myapp_sql_repo}
				2> myapp_sql_repo:test_connection().
				** exception error: no match of right hand side value {error,
				                                                       "[Microsoft][ODBC Driver
				Manager] The specified DSN contains an architecture mismatch between the Driver
				and Application SQLSTATE IS: IM014 Connection to database failed."}
				     in function  myapp_sql_repo:connect/0 (myapp_sql_repo.erl, line 33)
				     in call from myapp_sql_repo:test_connection/0 (myapp_sql_repo.erl, line 9)
				3>
			</pre>
			<p>If you encounter this error, simply replace the DSN with a new one using the correct architecture for your Erlang system.</p>


			<h3>Row Counts and Pattern Matching</h3>
			<p>When you have a stored procedure or batch of SQL statements that include statements which return counts rather than result sets (for example, UPDATE, INSERT, DELETE) you may find that the returned record counts break the pattern matching in your Erlang code.
			</p>
			<p> Suppose I want to insert a new employee record into a <code>employee</code> table, and then return the updated list of all employees:
			</p>
			<pre class="brush: erlang">
				create_employee(Name) ->
					Sql = "INSERT INTO employee VALUES(name); SELECT * FROM employee;"
					Connection = connect(),
				    case odbc:sql_query(Connection, Sql) of
				        {selected, Columns, Results} ->
				          % Results now contains the employee list
				          ok;
				        {error, Reason} ->
				            {error, Reason}                           
				    end. 
			</pre>
			<p>This code looks great, but when it runs it will produce a <code>bad_match</code> error in the <code>case</code> because the first item returned in the overall result set is the counter indicating that 1 row was inserted before the <code>SELECT</code> statement was executed. To fix the problem, add a <code>NOCOUNT</code> directive to prevent the counter from being returned:
			</p>
			<pre class="brush: erlang">
				create_employee(Name) ->
					Sql = "SET NOCOUNT ON; INSERT INTO employee VALUES(name); SELECT * FROM employee;"
					Connection = connect(),
				    case odbc:sql_query(Connection, Sql) of
				        {selected, Columns, Results} ->
				          % Results now contains the employee list
				          ok;
				        {error, Reason} ->
				            {error, Reason}                           
				    end. 
			</pre>
			<p>This issue crops up frequently when using stored procedures, since the whole point of a procedure is to encapsulate several operations into a single, concise SQL command. Fix it in the same way by adding <code>SET NOCOUNT ON</code> inside your stored procedure before you begin running other SQL commands.
			</p>
		</div>
	</section>

</div>
